Index: src/com/hehe/Classic/Z_ShapeChange.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.hehe.Classic;\r\n/*题目描述：Z字形排列变换\r\n * 将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。\r\n * Z字形排列：\r\n *\r\n * L   C   I   R\r\n   E T O E S I I G\r\n   E   D   H   N\r\n *\r\n * 示例 1:\r\n\r\n\t输入: s = \"LEETCODEISHIRING\", numRows = 3\r\n\t输出: \"LCIRETOESIIGEDHN\"\r\n   示例 2:\r\n\r\n\t输入: s = \"LEETCODEISHIRING\", numRows = 4\r\n\t输出: \"LDREOEIIECIHNTSG\"\r\n *\r\n * L     D     R\r\n   E   O E   I I\r\n   E C   I H   N\r\n   T     S     G\r\n * */\r\n\r\npublic class Z_ShapeChange {\r\n\r\n    public static void main(String[] args) {\r\n        String s =\"LEETCODEISHIRING\";\r\n        int numRows = 3;\r\n        String ret = convert(s, numRows);\r\n        System.out.println(ret);\r\n\r\n    }\r\n\r\n    /**\r\n     * 将之字形字符串按行打印出来\r\n     * @param s\r\n     * @param numRows\r\n     * @return\r\n     */\r\n    public static String convert(String s, int numRows) {\r\n\r\n        if (numRows == 1) return s;\r\n\r\n        StringBuilder ret = new StringBuilder();\r\n        int n = s.length();\r\n        //循环长度：\r\n        int cycleLen = 2 * numRows - 2;\r\n\r\n        //按行访问\r\n        for (int i = 0; i < numRows; i++) {\r\n            for (int j = 0; j + i < n; j += cycleLen) {\r\n\r\n                ret.append(s.charAt(j + i));\r\n                //非第一行和非最后一行时 s 的下标\r\n                if (i != 0 && i != numRows - 1 && j + cycleLen - i < n)\r\n                    ret.append(s.charAt(j + cycleLen - i));\r\n            }\r\n        }\r\n        return ret.toString();\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/hehe/Classic/Z_ShapeChange.java	(revision f5c8ab8c28f994e990c1a026ce0be39bbb810fc2)
+++ src/com/hehe/Classic/Z_ShapeChange.java	(date 1599557514634)
@@ -22,6 +22,9 @@
    T     S     G
  * */
 
+import java.util.ArrayList;
+import java.util.List;
+
 public class Z_ShapeChange {
 
     public static void main(String[] args) {
@@ -60,4 +63,20 @@
         return ret.toString();
     }
 
+    public String convert01(String s, int numRows) {
+        if(numRows < 2) return s;
+        List<StringBuilder> rows = new ArrayList<StringBuilder>();
+        for(int i = 0; i < numRows; i++) rows.add(new StringBuilder());
+        int i = 0, flag = -1;
+        for(char c : s.toCharArray()) {
+            rows.get(i).append(c);
+            if(i == 0 || i == numRows -1) flag = - flag;
+            i += flag;
+        }
+        StringBuilder res = new StringBuilder();
+        for(StringBuilder row : rows) res.append(row);
+        return res.toString();
+    }
+
+
 }
Index: src/com/hehe/Test/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.hehe.Test;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.Scanner;\r\n\r\n\r\npublic class Main {\r\n    public static void main(String[] args) {\r\n//        System.out.println(Math.round(-1.5));\r\n    }\r\n\r\n\r\n    public static int walk01(int[][] matrix) {\r\n        return walkll(matrix,0,0);\r\n    }\r\n\r\n    private static int walkll(int[][] matrix, int i, int j) {\r\n        if(i == matrix.length-1 && j == matrix[0].length-1)\r\n            return matrix[i][j];\r\n        if(i == matrix.length-1){\r\n            return matrix[i][j] + walkll(matrix,i,j+1);\r\n        }\r\n        if(j == matrix[0].length-1){\r\n            return matrix[i][j] + walkll(matrix,i+1,j);\r\n        }\r\n\r\n        int right = walkll(matrix,i,j+1);\r\n        int down = walkll(matrix,i+1,j);\r\n        return matrix[i][j] + Math.min(right,down);\r\n    }\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/hehe/Test/Main.java	(revision f5c8ab8c28f994e990c1a026ce0be39bbb810fc2)
+++ src/com/hehe/Test/Main.java	(date 1599559530378)
@@ -8,6 +8,12 @@
 public class Main {
     public static void main(String[] args) {
 //        System.out.println(Math.round(-1.5));
+        System.out.println(foo(12,20));
+    }
+    static int foo(int x,int y){
+        if(x <= 0 || y <= 0)
+            return 1;
+        return 3 * foo(x-6,y/2);
     }
 
 
Index: src/com/hehe/String/LongestPalindrome.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.hehe.String;\r\n\r\npublic class LongestPalindrome {\r\n    public static void main(String[] args) {\r\n        System.out.println(\"=============最长回文子串 Manacher==============\");\r\n        System.out.println(longestPalindrome01(\"abccccdd\"));\r\n        System.out.println(longestPalindrome02(\"abccccdd\"));\r\n\r\n\r\n        System.out.println(\"==============回文子串的个数和最长回文子串=================\");\r\n        int[] res = numOfPalindrome(\"abccdccc\");\r\n        System.out.println(res[0] + \" \" + res[1]);\r\n\r\n    }\r\n\r\n    /**\r\n     * 1、回文串的个数和最长回文子串\r\n     * zf 中心扩展法\r\n     * @param s\r\n     * @return\r\n     */\r\n    public static int[] numOfPalindrome(String s) {\r\n        int[] res = new int[2];\r\n        int n = 2 * s.length() - 1;  //从第一个到最后一个字母 依次以一个或者连续两个元素为中心扩展\r\n        int l = 0;\r\n        for (int i = 0; i < n; i++) {\r\n            int left = i / 2;\r\n            int right = left + i % 2;\r\n            while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\r\n                if (right - left > 0)\r\n                    res[0]++;\r\n                l = Math.max(l, right - left + 1);\r\n                left--;\r\n                right++;\r\n\r\n            }\r\n        }\r\n        res[1] = l;\r\n        return res;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * 2、最长回文子串 暴力\r\n     * O（n^3）\r\n     *\r\n     * @param s\r\n     * @return\r\n     */\r\n    public static String longestPalindrome01(String s) {\r\n//        if (s == null || s.length() <= 0)\r\n//            return null;\r\n        if (s.length() < 2) {\r\n            return s;\r\n        }\r\n        int maxLen = 0;\r\n        int begin = 0;\r\n        char[] chars = s.toCharArray();\r\n        for (int i = 0; i < chars.length; i++) {\r\n            for (int j = 1; j < chars.length; j++) {\r\n                if (j - i + 1 > maxLen && validPalindromic(chars, i, j)) {  //i ~ j的字符串是否是回文串\r\n                    begin = i;\r\n                    maxLen = j - i + 1;\r\n                }\r\n            }\r\n        }\r\n        return s.substring(begin, begin + maxLen);\r\n\r\n    }\r\n\r\n    /**\r\n     * 验证子串 s[left..right] 是否为回文串\r\n     */\r\n    private static boolean validPalindromic(char[] charArray, int left, int right) {\r\n        while (left < right) {\r\n            if (charArray[left] != charArray[right])\r\n                return false;\r\n            left++;\r\n            right--;\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * 3、最长回文子串 Manacher\r\n     * O（N^2）\r\n     * @param s\r\n     * @return\r\n     */\r\n    public static String longestPalindrome02(String s) {\r\n        int len = s.length();\r\n        if (len < 2) {\r\n            return s;\r\n        }\r\n        String str = addBoundaries(s, '#');   //加边界\r\n        int sLen = 2 * len + 1;\r\n        int maxLen = 1;\r\n\r\n        int start = 0;\r\n        for (int i = 0; i < sLen; i++) {\r\n            int curLen = centerSpread(str, i);   //中心扩散求长度\r\n            if (curLen > maxLen) {\r\n                maxLen = curLen;\r\n                start = (i - maxLen) / 2;\r\n            }\r\n        }\r\n        return s.substring(start, start + maxLen);\r\n    }\r\n\r\n    /**\r\n     * 中心扩散求长度\r\n     * @param s\r\n     * @param center\r\n     * @return\r\n     */\r\n    private static int centerSpread(String s, int center) {\r\n        int len = s.length();\r\n        int i = center - 1;\r\n        int j = center + 1;\r\n        int step = 0;\r\n        while (i >= 0 && j < len && s.charAt(i) == s.charAt(j)) {\r\n            i--;\r\n            j++;\r\n            step++;\r\n        }\r\n        return step;\r\n    }\r\n\r\n    /**\r\n     * 创建预处理字符串\r\n     *\r\n     * @param s      原始字符串\r\n     * @param divide 分隔字符\r\n     * @return 使用分隔字符处理以后得到的字符串\r\n     */\r\n    private static String addBoundaries(String s, char divide) {\r\n        int len = s.length();\r\n        if (len == 0) {\r\n            return \"\";\r\n        }\r\n        if (s.indexOf(divide) != -1) {\r\n            throw new IllegalArgumentException(\"参数错误，您传递的分割字符，在输入字符串中存在！\");\r\n        }\r\n\r\n        StringBuilder sb = new StringBuilder();\r\n        for (int i = 0; i < len; i++) {\r\n            sb.append(divide);\r\n            sb.append(s.charAt(i));\r\n        }\r\n        sb.append(divide);\r\n        return sb.toString();\r\n    }\r\n\r\n    //===============================================未看============================================================\r\n    /**\r\n     * 4、最长回文子串 Manacher\r\n     * O（N）\r\n     * @param s\r\n     * @return\r\n     */\r\n    public String longestPalindrome(String s) {\r\n        // 特判\r\n        int len = s.length();\r\n        if (len < 2) {\r\n            return s;\r\n        }\r\n\r\n        // 得到预处理字符串\r\n        String str = addBoundaries(s, '#');\r\n        // 新字符串的长度\r\n        int sLen = 2 * len + 1;\r\n\r\n        // 数组 p 记录了扫描过的回文子串的信息\r\n        int[] p = new int[sLen];\r\n\r\n        // 双指针，它们是一一对应的，须同时更新\r\n        int maxRight = 0;\r\n        int center = 0;\r\n\r\n        // 当前遍历的中心最大扩散步数，其值等于原始字符串的最长回文子串的长度\r\n        int maxLen = 1;\r\n        // 原始字符串的最长回文子串的起始位置，与 maxLen 必须同时更新\r\n        int start = 0;\r\n\r\n        for (int i = 0; i < sLen; i++) {\r\n            if (i < maxRight) {\r\n                int mirror = 2 * center - i;\r\n                // 这一行代码是 Manacher 算法的关键所在，要结合图形来理解\r\n                p[i] = Math.min(maxRight - i, p[mirror]);\r\n            }\r\n\r\n            // 下一次尝试扩散的左右起点，能扩散的步数直接加到 p[i] 中\r\n            int left = i - (1 + p[i]);\r\n            int right = i + (1 + p[i]);\r\n\r\n            // left >= 0 && right < sLen 保证不越界\r\n            // str.charAt(left) == str.charAt(right) 表示可以扩散 1 次\r\n            while (left >= 0 && right < sLen && str.charAt(left) == str.charAt(right)) {\r\n                p[i]++;\r\n                left--;\r\n                right++;\r\n\r\n            }\r\n            // 根据 maxRight 的定义，它是遍历过的 i 的 i + p[i] 的最大者\r\n            // 如果 maxRight 的值越大，进入上面 i < maxRight 的判断的可能性就越大，这样就可以重复利用之前判断过的回文信息了\r\n            if (i + p[i] > maxRight) {\r\n                // maxRight 和 center 需要同时更新\r\n                maxRight = i + p[i];\r\n                center = i;\r\n            }\r\n            if (p[i] > maxLen) {\r\n                // 记录最长回文子串的长度和相应它在原始字符串中的起点\r\n                maxLen = p[i];\r\n                start = (i - maxLen) / 2;\r\n            }\r\n        }\r\n        return s.substring(start, start + maxLen);\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/hehe/String/LongestPalindrome.java	(revision f5c8ab8c28f994e990c1a026ce0be39bbb810fc2)
+++ src/com/hehe/String/LongestPalindrome.java	(date 1599553373013)
@@ -2,14 +2,17 @@
 
 public class LongestPalindrome {
     public static void main(String[] args) {
-        System.out.println("=============最长回文子串 Manacher==============");
-        System.out.println(longestPalindrome01("abccccdd"));
-        System.out.println(longestPalindrome02("abccccdd"));
+//        System.out.println("=============最长回文子串 Manacher==============");
+//        System.out.println(longestPalindrome01("abccccdd"));
+//        System.out.println(longestPalindrome02("abccccdd"));
+//
+//
+//        System.out.println("==============回文子串的个数和最长回文子串=================");
+//        int[] res = numOfPalindrome("abccdccc");
+//        System.out.println(res[0] + " " + res[1]);
 
 
-        System.out.println("==============回文子串的个数和最长回文子串=================");
-        int[] res = numOfPalindrome("abccdccc");
-        System.out.println(res[0] + " " + res[1]);
+        System.out.println(longestPalindrome03("babad"));
 
     }
 
@@ -154,6 +157,26 @@
         return sb.toString();
     }
 
+    public static String longestPalindrome03(String s) {
+        int n = 2 * s.length() - 1;
+        int maxLen = 0;
+        String res = "";
+        for (int i = 0; i < n; i++) {
+            int left = i / 2;
+            int right = left + i % 2;
+            while(left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)){
+                if((right - left + 1) > maxLen){
+                    res = s.substring(left,right +1);
+                    maxLen = right - left + 1;
+                }
+                left --;
+                right++;
+            }
+        }
+        return res;
+
+
+    }
     //===============================================未看============================================================
     /**
      * 4、最长回文子串 Manacher
Index: src/com/hehe/RecursiveAndDynamic/LongestSubstring.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.hehe.RecursiveAndDynamic;\r\n\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\n\r\n/**\r\n * 最长不重复子串\r\n */\r\npublic class LongestSubstring {\r\n\r\n    public static void main(String[] args) {\r\n        System.out.println(lengthOfLongestSubstring(\"arabcacfr\"));\r\n        System.out.println(lengthOfLongestSubstring01(\"arabcacfr\"));\r\n    }\r\n\r\n    /**\r\n     * 1、\r\n     * @param s\r\n     * @return\r\n     */\r\n    public static int lengthOfLongestSubstring(String s) {\r\n        int res = 0, tmp = 0;\r\n        Map<Character, Integer> map = new HashMap<>();\r\n\r\n        for (int i = 0; i < s.length(); i++) {\r\n            int index = map.getOrDefault(s.charAt(i), -1);\r\n\r\n            //tmp只记录当前的不重复的子串的长度 小于成立说明不重复 大于说明当前非最长\r\n            //而tmp只记录以当前字符结尾的无重复字符的长度 故 赋给它i-index\r\n            tmp = tmp < i - index ? tmp + 1 : i - index; // dp[j - 1] -> dp[j]\r\n\r\n            res = Math.max(tmp, res);  // max(dp[j - 1], dp[j])\r\n            map.put(s.charAt(i), i); //更新哈希表\r\n        }\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * 2、\r\n     * @param s\r\n     * @return\r\n     */\r\n    public static int lengthOfLongestSubstring01(String s) {\r\n        if (s.length() == 0)\r\n            return 0;\r\n\r\n        HashMap<Character, Integer> map = new HashMap<>();\r\n        int max = 0;\r\n        int left = 0;\r\n\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (map.containsKey(s.charAt(i))) {\r\n                left = Math.max(left, map.get(s.charAt(i)) + 1);\r\n            }\r\n            map.put(s.charAt(i), i);\r\n            max = Math.max(max, i - left + 1);\r\n        }\r\n        return max;\r\n\r\n    }\r\n\r\n}\r\n
===================================================================
--- src/com/hehe/RecursiveAndDynamic/LongestSubstring.java	(revision f5c8ab8c28f994e990c1a026ce0be39bbb810fc2)
+++ src/com/hehe/String/LongestSubstring.java	(date 1599550253503)
@@ -1,7 +1,9 @@
-package com.hehe.RecursiveAndDynamic;
+package com.hehe.String;
 
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.Map;
+import java.util.Set;
 
 /**
  * 最长不重复子串
@@ -9,12 +11,49 @@
 public class LongestSubstring {
 
     public static void main(String[] args) {
-        System.out.println(lengthOfLongestSubstring("arabcacfr"));
-        System.out.println(lengthOfLongestSubstring01("arabcacfr"));
+//        System.out.println(lengthOfLongestSubstring("arabcacfr"));
+//        System.out.println(lengthOfLongestSubstring01("arabcacfr"));
+
+        System.out.println("+++++++++++++++++++++++++");
+//        System.out.println(lengthOfLongestSubstring("awwke"));
+//        System.out.println(lengthOfLongestSubstring("bbbbb"));
+//        System.out.println(lengthOfLongestSubstring("abcabcbb"));
+        System.out.println("===========================");
+        System.out.println(lengthOfLongestSubstring03("awwke"));
+//        System.out.println(lengthOfLongestSubstring03("bbbbb"));
+//        System.out.println(lengthOfLongestSubstring03("abcabcbb"));
+    }
+
+
+    /**
+     * 有点难懂！！
+     * @param s
+     * @return
+     */
+    public static int lengthOfLongestSubstring03(String s) {
+        // 哈希集合，记录每个字符是否出现过
+        Set<Character> occ = new HashSet<Character>();
+        // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动
+        int rk = -1, ans = 0;
+        for (int i = 0; i < s.length(); ++i) {
+            if (i != 0) {
+                // 左指针向右移动一格，移除一个字符
+                occ.remove(s.charAt(i - 1));
+            }
+            while (rk + 1 < s.length() && !occ.contains(s.charAt(rk + 1))) {
+                // 不断地移动右指针
+                occ.add(s.charAt(rk + 1));
+                ++rk;
+            }
+            // 第 i 到 rk 个字符是一个极长的无重复字符子串
+            ans = Math.max(ans, rk - i + 1);
+        }
+        return ans;
     }
 
     /**
      * 1、
+     *
      * @param s
      * @return
      */
@@ -37,6 +76,7 @@
 
     /**
      * 2、
+     *
      * @param s
      * @return
      */
Index: src/com/interview/T20200823_zijie1.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/interview/T20200823_zijie1.java	(date 1599539542461)
+++ src/com/interview/T20200823_zijie1.java	(date 1599539542461)
@@ -0,0 +1,63 @@
+package com.interview;
+
+import com.sun.xml.internal.ws.policy.privateutil.PolicyUtils;
+
+import java.security.spec.RSAOtherPrimeInfo;
+import java.util.*;
+
+/**
+ * 生成序列
+ */
+public class T20200823_zijie1 {
+    public static void main(String[] args) {
+        Scanner sc = new Scanner(System.in);
+        int n = sc.nextInt();
+        int l = sc.nextInt();
+        int r = sc.nextInt();
+
+        int[] arr = new int[r - l + 1];
+        int num = r - l + 1;
+        for (int i = 0; i < num; i++) {
+            arr[i] = l;
+            l++;
+        }
+
+        int count = 0;
+        int[] arr2 = Arrays.copyOf(arr, arr.length);
+        ArrayList<Integer> list = new ArrayList<>();
+        List<List<Integer>> llist = new ArrayList<>();
+        while (n >= 1) {
+            list.add(selectOne(arr2));
+            n--;
+        }
+        if(sumAll(arr2) % 3 == 0 && isOk(llist,list))
+            count++;
+        System.out.println(count);
+
+
+    }
+
+    private static boolean isOk(List<List<Integer>> llist, ArrayList<Integer> list) {
+
+
+        return false;
+    }
+
+    private static int sumAll(int[] arr) {
+        int sum = 0;
+        for (int i = 0; i < arr.length; i++)
+            sum+=arr[i];
+        return sum;
+    }
+
+    private static int selectOne(int[] arr) {
+        int res = 0;
+        for (int i = 0; i < arr.length; i++) {
+            if (arr[i] != -1){
+                res = arr[i];
+                break;
+            }
+        }
+        return res;
+    }
+}
Index: src/com/hehe/SortAndSearch/HeapSort01.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/hehe/SortAndSearch/HeapSort01.java	(date 1599539542446)
+++ src/com/hehe/SortAndSearch/HeapSort01.java	(date 1599539542446)
@@ -0,0 +1,45 @@
+package com.hehe.SortAndSearch;
+
+public class HeapSort01 {
+    public static void heapSort(int[] nums){
+        if (nums == null || nums.length < 2)
+            return;
+        for (int i = 0; i < nums.length; i++) {
+            heapInsert(nums,i);//构建大根堆
+        }
+        int size = nums.length;
+        //交换根节点和最后一个节点
+        swap(nums, 0, --size);
+        while (size > 0){
+            heapify(nums, 0, size);//调整
+            swap(nums, 0, --size);//交换
+        }
+    }
+    //根节点向下调整
+    private static void heapify(int[] nums, int i, int size) {
+        int left = 2*i+1;
+        while (left < size){//左孩子存在
+            int largest = left+1 < size && nums[left+1] > nums[left] ? left+1:left;
+            largest = nums[largest] > nums[i] ? largest : i;
+            if (largest == i)
+                break;
+            swap(nums,largest,i);
+            i=largest;
+            left = 2*i+1;
+        }
+    }
+
+    private static void heapInsert(int[] nums, int i) {
+        while (nums[i] > nums[(i-1)/2]){
+            //插入节点大于根节点
+            swap(nums,i,(i-1)/2);
+            i = (i-1)/2;
+        }
+    }
+
+    private static void swap(int[] nums, int i, int j) {
+        int tmp = nums[i];
+        nums[i] = nums[j];
+        nums[j] = tmp;
+    }
+}
Index: src/com/hehe/ProducerConsumer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/hehe/ProducerConsumer.java	(date 1599539542504)
+++ src/com/hehe/ProducerConsumer.java	(date 1599539542504)
@@ -0,0 +1,80 @@
+//package com.hehe;
+//
+//import java.util.concurrent.RecursiveTask;
+//
+//public class ProducerConsumer {
+//        private static BlockingQueue<String> queue = new ArrayBlockingQueue<>(5);
+//        private static class Producer extends Thread {
+//            @Override
+//            public void run() {
+//                try {
+//                    queue.put("product");
+//                } catch (InterruptedException e) {
+//                    e.printStackTrace();
+//                } S
+//                ystem.out.print("produce..");
+//            }
+//        } p
+//        rivate static class Consumer extends Thread {
+//            @Override
+//            public void run() {
+//                try {
+//                    String product = queue.take();
+//                } catch (InterruptedException e) {
+//                    e.printStackTrace();produce..produce..consume..consume..produce..consume..produce..consume..produce..consume.
+//.
+//                    ForkJoin
+//                    主要用于并行计算中，和 MapReduce 原理类似，都是把大的计算任务拆分成多个小任务并行计算。
+//                } S
+//                ystem.out.print("consume..");
+//            }
+//        }
+//    }
+//    ublic static void main(String[] args) {
+//        for (int i = 0; i < 2; i++) {
+//            Producer producer = new Producer();
+//            producer.start();
+//        } f
+//        or (int i = 0; i < 5; i++) {
+//            Consumer consumer = new Consumer();
+//            consumer.start();
+//        } f
+//        or (int i = 0; i < 3; i++) {
+//            Producer producer = new Producer();
+//            producer.start();
+//        }
+//    }
+//    public class ForkJoinExample extends RecursiveTask<Integer> {
+//        private final int threshold = 5;
+//        private int first;
+//        private int last;
+//        public ForkJoinExample(int first, int last) {
+//            this.first = first;
+//            this.last = last;
+//        }
+//        @Override
+//        protected Integer compute() {
+//            int result = 0;
+//            if (last - first <= threshold) {
+//// 任务足够小则直接计算
+//                for (int i = first; i <= last; i++) {
+//                    result += i;
+//                }
+//            } else {
+//// 拆分成小任务
+//                int middle = first + (last - first) / 2;
+////                ForkJoin 使用 ForkJoinPool 来启动，它是一个特殊的线程池，线程数量取决于 CPU 核数。
+////                ForkJoinPool 实现了工作窃取算法来提高 CPU 的利用率。每个线程都维护了一个双端队列，用来存储需要执行的
+////                任务。工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行。窃取的任务必须是最晚的任
+////                务，避免和队列所属线程发生竞争。例如下图中，Thread2 从 Thread1 的队列中拿出最晚的 Task1 任务，
+////                Thread1 会拿出 Task2 来执行，这样就避免发生竞争。但是如果队列中只有一个任务时还是会发生竞争。
+////                9. 线程不安全示例
+//                ForkJoinExample leftTask = new ForkJoinExample(first, middle);
+//                ForkJoinExample rightTask = new ForkJoinExample(middle + 1, last);
+//                leftTask.fork();
+//                rightTask.fork();
+//                result = leftTask.join() + rightTask.join();
+//            }
+//            return result;
+//        }
+//    }
Index: src/com/hehe/Test/T1.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/hehe/Test/T1.java	(date 1599539542659)
+++ src/com/hehe/Test/T1.java	(date 1599539542659)
@@ -0,0 +1,13 @@
+package com.hehe.Test;
+
+public class T1 {
+    public static void main(String[] args) {
+        Integer i = 1,j = 1;
+        System.out.println(i == j);
+        System.out.println(i.equals(j));
+
+        Integer m = 200,n = 200;
+        System.out.println(m == n);
+        System.out.println(m.equals(n));
+    }
+}
Index: src/com/interview/T20200717_niuke2.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/interview/T20200717_niuke2.java	(date 1599539542607)
+++ src/com/interview/T20200717_niuke2.java	(date 1599539542607)
@@ -0,0 +1,21 @@
+package com.interview;
+
+public class T20200717_niuke2 {
+    public static void main(String[] args) {
+
+
+    }
+
+    //【牛牛吃雪糕】最近天气太热了，牛牛每天都要吃雪糕。雪糕有一盒一份、一盒两份、一盒三份这三种包装，牛牛一天可以吃多盒雪糕，但是只能吃六份，吃多了就会肚子疼，吃少了就会中暑。
+    // 而且贪吃的牛牛一旦打开一盒雪糕，就一定会把它吃完。请问牛牛能健康地度过这段高温期么？
+    // 每个输入包含多个测试用例。输入的第一行包括一个正整数，表示数据组数T(1<=T<=100)。
+    // 接下来N行，每行包含四个正整数，表示高温期持续的天数N(1<=N<=10000)，一盒一份包装的雪糕数量A(1<=A<=100000)，一盒两份包装的雪糕数量B(1<=B<=100000)，一盒三份包装的雪糕数量C(1<=A<=100000)。
+    // 对于每个用例，在单独的一行中输出结果。如果牛牛可以健康地度过高温期则输出"Yes"，否则输出"No"。
+    // 4
+    // 1 1 1 1
+    // 2 0 0 4
+    // 3 0 2 5
+    // 4 24 0 0
+    // Yes Yes No Yes
+
+}
