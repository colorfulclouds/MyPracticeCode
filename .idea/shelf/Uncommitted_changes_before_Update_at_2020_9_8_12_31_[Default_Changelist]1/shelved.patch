Index: src/com/hehe/Classic/RegularMatch.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.hehe.Classic;\r\n\r\n/**\r\n *请实现一个函数用来匹配包含'. '和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。\r\n * 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串\"aaa\"与模式\"a.a\"和\"ab*ac*a\"匹配，但与\"aa.a\"和\"ab*a\"均不匹配。\r\n *\r\n */\r\npublic class RegularMatch {\r\n    public static void main(String[] args) {\r\n        System.out.println(isMatch(\"aaa\", \"a.a\"));\r\n        System.out.println(isMatch(\"aaa\", \"ab*ac*a\"));\r\n        System.out.println(isMatch(\"aaa\", \"aa.a\"));\r\n        System.out.println(isMatch(\"aaa\", \"ab*a\"));\r\n        System.out.println(isMatch(\"aaa\", \".*\"));\r\n\r\n//        true\r\n//        true\r\n//        false\r\n//        false\r\n    }\r\n\r\n    static boolean isMatch(String str, String patten) {\r\n        if (str.isEmpty() && patten.isEmpty())\r\n            return true;\r\n        return MatchCore(str, patten);\r\n    }\r\n\r\n\r\n    private static boolean MatchCore(String str, String patten) {\r\n        if (str.isEmpty())\r\n            return patten.isEmpty();\r\n        if(patten.isEmpty())\r\n            return str.isEmpty();\r\n\r\n        if (patten.length() > 1 && patten.charAt(1) == '*' && str.length() >= 1) { //patten 至少为 q*样子\r\n\r\n            if (str.charAt(0) == patten.charAt(0) || patten.charAt(0) == '.')\r\n                return MatchCore(str, patten.substring(2)) //patten后面可能有 x* 去匹配 0+ 个str中的字符\r\n                        || MatchCore(str.substring(1), patten)\r\n                        || MatchCore(str.substring(1), patten.substring(2));\r\n            else\r\n                return MatchCore(str, patten.substring(2));\r\n        }\r\n        if ((str.charAt(0) == patten.charAt(0) && str.length() >= 1 && patten.length() >= 1)\r\n                || (patten.charAt(0) == '.' && str.length() >= 1))\r\n            return MatchCore(str.substring(1), patten.substring(1));\r\n        return false;\r\n    }\r\n\r\n\r\n    public boolean isMatch01(String s, String p) {\r\n        //如果正则串p为空字符串s也为空这匹配成功，如果正则串p为空但是s不是空则说明匹配失败\r\n        if (p.isEmpty()) return s.isEmpty();\r\n        //判断s和p的首字符是否匹配，注意要先判断s不为空\r\n        boolean headMatched = !s.isEmpty() && (s.charAt(0) == p.charAt(0) || p.charAt(0) == '.');\r\n        if (p.length() >= 2 && p.charAt(1) == '*') {//如果p的第一个元素的下一个元素是*\r\n            //则分别对两种情况进行判断\r\n            return isMatch01(s, p.substring(2)) ||\r\n                    (headMatched && isMatch(s.substring(1), p));\r\n        } else if (headMatched) {//否则，如果s和p的首字符相等\r\n            return isMatch01(s.substring(1), p.substring(1));\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n\r\n}\r\n
===================================================================
--- src/com/hehe/Classic/RegularMatch.java	(revision 49a4e2ff04d1cdadecf01189b626421177ab47d2)
+++ src/com/hehe/String/RegularMatch.java	(date 1599488572086)
@@ -1,4 +1,6 @@
-package com.hehe.Classic;
+package com.hehe.String;
+
+
 
 /**
  *请实现一个函数用来匹配包含'. '和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。
@@ -7,16 +9,59 @@
  */
 public class RegularMatch {
     public static void main(String[] args) {
-        System.out.println(isMatch("aaa", "a.a"));
-        System.out.println(isMatch("aaa", "ab*ac*a"));
-        System.out.println(isMatch("aaa", "aa.a"));
-        System.out.println(isMatch("aaa", "ab*a"));
-        System.out.println(isMatch("aaa", ".*"));
+//        System.out.println(isMatch("aaa", "a.a"));
+//        System.out.println(isMatch("aaa", "ab*ac*a"));
+//        System.out.println(isMatch("aaa", "aa.a"));
+//        System.out.println(isMatch("aaa", "ab*a"));
+//        System.out.println(isMatch("aaa", ".*"));
 
 //        true
 //        true
 //        false
 //        false
+//        true
+
+        System.out.println(match("aaa".toCharArray(), "a.a".toCharArray()));
+        System.out.println(match("aaa".toCharArray(), "ab*ac*a".toCharArray()));
+        System.out.println(match("aaa".toCharArray(), "aa.a".toCharArray()));
+        System.out.println(match("aaa".toCharArray(), "ab*a".toCharArray()));
+        System.out.println(match("aaa".toCharArray(), ".*".toCharArray()));
+
+    }
+
+    public static boolean match(char[] str, char[] pattern) {
+        if (str == null || pattern == null) {
+            return false;
+        }
+        int strIndex = 0;
+        int patternIndex = 0;
+        return matchCore(str, strIndex, pattern, patternIndex);
+    }
+
+    public static boolean matchCore(char[] str, int strIndex, char[] pattern, int patternIndex) {
+        //有效性检验：str到尾，pattern到尾，匹配成功
+        if (strIndex == str.length && patternIndex == pattern.length) {
+            return true;
+        }
+        //pattern先到尾，匹配失败
+        if (strIndex != str.length && patternIndex == pattern.length) {
+            return false;
+        }
+        //模式第2个是*，且字符串第1个跟模式第1个匹配,分3种匹配模式；如不匹配，模式后移2位
+        if (patternIndex + 1 < pattern.length && pattern[patternIndex + 1] == '*') {
+            if ((strIndex != str.length && pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == '.' && strIndex != str.length)) {
+                return matchCore(str, strIndex, pattern, patternIndex + 2)//模式后移2，视为x*匹配0个字符
+                        || matchCore(str, strIndex + 1, pattern, patternIndex + 2)//视为模式匹配1个字符
+                        || matchCore(str, strIndex + 1, pattern, patternIndex);//*匹配1个，再匹配str中的下一个
+            } else {
+                return matchCore(str, strIndex, pattern, patternIndex + 2);
+            }
+        }
+        //模式第2个不是*，且字符串第1个跟模式第1个匹配，则都后移1位，否则直接返回false
+        if ((strIndex != str.length && pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == '.' && strIndex != str.length)) {
+            return matchCore(str, strIndex + 1, pattern, patternIndex + 1);
+        }
+        return false;
     }
 
     static boolean isMatch(String str, String patten) {
@@ -45,6 +90,7 @@
                 || (patten.charAt(0) == '.' && str.length() >= 1))
             return MatchCore(str.substring(1), patten.substring(1));
         return false;
+
     }
 
 
Index: src/com/hehe/String/StringPattern_easy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.hehe.String;\r\nimport java.util.Scanner;\r\n\r\n/**题意\r\n * 模式匹配, 串中包含的模式串的个数\r\n * 其中？为万能符\r\n * ababa\r\n * aba\r\n * 2\r\n * <p>\r\n * aba?a\r\n * aba\r\n * 2\r\n */\r\n\r\n//思路：\r\n//暴力循环   s1.length() - s2.length()+1   次\r\n//父循环内：\r\n//    对子串循环，一个不匹配就结束，最后一个字符之前的匹配情况不用处理\r\n//              先处理匹配到最后一个字符且最后一个字符也匹配\r\n//    父循环继续\r\n\r\npublic class StringPattern_easy {\r\n\r\n    //求解字符串内含有多少模式串\r\n    public static int strPattern(String s1,String s2){\r\n        int count = 0;\r\n        int lim = s1.length() - s2.length();\r\n        int k = 0;\r\n        while (k <= lim) {\r\n            for (int j = 0; j < s2.length(); j++) {\r\n//                System.out.println(s1.charAt(k + j) + \"===\");\r\n//                System.out.println(s2.charAt(j));\r\n                if(j == s2.length() - 1 && (s1.charAt(k + j) == '?' || s1.charAt(k + j) == s2.charAt(j)))\r\n                    count++;\r\n                if (s1.charAt(k + j) != '?' && s1.charAt(k + j) != s2.charAt(j)) {\r\n                    break;\r\n                }\r\n            }\r\n            k++;\r\n        }\r\n        return count;\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n//        Scanner sc = new Scanner(System.in);\r\n//        String s1 = sc.nextLine();\r\n//        String s2 = sc.nextLine();\r\n\r\n        String s1 = \"ababa\";\r\n        String s2 = \"ababaaba\";\r\n        String s3 = \"aba\";\r\n\r\n        System.out.println(strPattern(s1,s3));\r\n        System.out.println(strPattern(s2,s3));\r\n\r\n        //matches\r\n        System.out.println(s1.matches(\"(.*)\"));\r\n    }\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/hehe/String/StringPattern_easy.java	(revision 49a4e2ff04d1cdadecf01189b626421177ab47d2)
+++ src/com/hehe/String/StringPattern_easy.java	(date 1599461895672)
@@ -48,8 +48,8 @@
 //        String s2 = sc.nextLine();
 
         String s1 = "ababa";
-        String s2 = "ababaaba";
-        String s3 = "aba";
+        String s2 = "ababaabc";
+        String s3 = "abc";
 
         System.out.println(strPattern(s1,s3));
         System.out.println(strPattern(s2,s3));
Index: src/com/hehe/String/FirstOnceChar_easy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.hehe.String;\r\n\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\n\r\npublic class FirstOnceChar_easy {\r\n    public static void main(String[] args) {\r\n\r\n        System.out.println(firstOnceChar(\"ababac\"));\r\n        System.out.println(firstOnceChar01(\"ababac\"));\r\n    }\r\n\r\n    /**\r\n     * 找字符串里第一次出现的字符\r\n     * @param s\r\n     * @return\r\n     */\r\n    public static char firstOnceChar(String s){\r\n        Map<Character,Integer> map = new HashMap<>();\r\n        char[] chars = s.toCharArray();\r\n        for(char c : chars){\r\n            if (map.containsKey(c)) {\r\n                map.put(c,map.get(c)+1);\r\n            } else {\r\n                map.put(c, 1);\r\n            }\r\n        }\r\n        for(char c : chars){\r\n            if (map.get(c) == 1)\r\n                return c;\r\n        }\r\n        return ' ';\r\n    }\r\n\r\n    /**\r\n     * 在一个字符串(0<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数）\r\n     * @param s\r\n     * @return\r\n     */\r\n    public static int firstOnceChar01(String s){\r\n        Map<Character,Integer> map = new HashMap<>();\r\n        char[] chars = s.toCharArray();\r\n        for(char c : chars){\r\n            if (map.containsKey(c)) {\r\n                map.put(c,map.get(c)+1);\r\n            } else {\r\n                map.put(c, 1);\r\n            }\r\n        }\r\n        int i = 0;\r\n        for(char c : chars){\r\n            if (map.get(c) == 1)\r\n                return i;\r\n            i++;\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/hehe/String/FirstOnceChar_easy.java	(revision 49a4e2ff04d1cdadecf01189b626421177ab47d2)
+++ src/com/hehe/String/FirstOnceChar_easy.java	(date 1599485023527)
@@ -6,26 +6,49 @@
 public class FirstOnceChar_easy {
     public static void main(String[] args) {
 
+
         System.out.println(firstOnceChar("ababac"));
         System.out.println(firstOnceChar01("ababac"));
     }
 
+
+    /**
+     * 找字符流中第一次出现的字符
+     */
+    int[] arr = new int[256];
+    String s = "";
+
+    public void Insert(char ch) {
+        s += ch;
+        arr[ch]++;
+    }
+
+    public char FirstAppearingOnce() {
+        char[] str = s.toCharArray();
+        for (char c : str) {
+            if (arr[c] == 1)
+                return c;
+        }
+        return '#';
+    }
+
     /**
      * 找字符串里第一次出现的字符
+     *
      * @param s
      * @return
      */
-    public static char firstOnceChar(String s){
-        Map<Character,Integer> map = new HashMap<>();
+    public static char firstOnceChar(String s) {
+        Map<Character, Integer> map = new HashMap<>();
         char[] chars = s.toCharArray();
-        for(char c : chars){
+        for (char c : chars) {
             if (map.containsKey(c)) {
-                map.put(c,map.get(c)+1);
+                map.put(c, map.get(c) + 1);
             } else {
                 map.put(c, 1);
             }
         }
-        for(char c : chars){
+        for (char c : chars) {
             if (map.get(c) == 1)
                 return c;
         }
@@ -34,21 +57,22 @@
 
     /**
      * 在一个字符串(0<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数）
+     *
      * @param s
      * @return
      */
-    public static int firstOnceChar01(String s){
-        Map<Character,Integer> map = new HashMap<>();
+    public static int firstOnceChar01(String s) {
+        Map<Character, Integer> map = new HashMap<>();
         char[] chars = s.toCharArray();
-        for(char c : chars){
+        for (char c : chars) {
             if (map.containsKey(c)) {
-                map.put(c,map.get(c)+1);
+                map.put(c, map.get(c) + 1);
             } else {
                 map.put(c, 1);
             }
         }
         int i = 0;
-        for(char c : chars){
+        for (char c : chars) {
             if (map.get(c) == 1)
                 return i;
             i++;
Index: src/com/hehe/Classic/NumOfBinary_1.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.hehe.Classic;\r\n\r\n\r\nimport java.util.Scanner;\r\n\r\n/**\r\n * 有疑问！！！\r\n * -10 运行结果为30！！！！\r\n */\r\n\r\n/**\r\n * 二进制中1的个数，其中负数用补码表示。\r\n * 注意：有负数！！！\r\n */\r\npublic class NumOfBinary_1 {\r\n\r\n    public static void main(String[] args) {\r\n//            System.out.println(nums1(11));\r\n//            System.out.println(nums2(11));\r\n\r\n//        Scanner sc = new Scanner(System.in);\r\n//        int input = Integer.parseInt(sc.nextLine());\r\n//        System.out.println(nums2(input));\r\n//        System.out.println(nums2(10));\r\n        System.out.println(nums2(-10));  //+10 : 01010 取反加1 得-10补码 10110\r\n        System.out.println(nums1(-10));  //+10 : 01010 取反加1 得-10补码 10110\r\n//        System.out.println(nums2(-2147483648));\r\n    }\r\n\r\n\r\n    /**\r\n     * 有几个1 就循环几次\r\n     * 分析：一个整数减去1，再和原整数做与运算，会把该整数最右边的 1 变为 0，整数中有几个 1 就进行多少次这样的操作\r\n     *\r\n     * @param n\r\n     * @return\r\n     */\r\n    public static int nums2(int n) {\r\n        int count = 0;\r\n        while (n != 0) {   //有负数 不能大于0，非零时对1的计数结束\r\n            ++count;\r\n            n = n & (n - 1);\r\n        }\r\n        return count;\r\n    }\r\n\r\n    /*n位循环n次\r\n     * */\r\n    public static int nums1(int n) {\r\n        int count = 0;\r\n        int flag = 1;\r\n        while (flag > 0) {\r\n            if ((flag & n) > 0)\r\n                count++;\r\n            flag = flag << 1;\r\n        }\r\n        return count;\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/hehe/Classic/NumOfBinary_1.java	(revision 49a4e2ff04d1cdadecf01189b626421177ab47d2)
+++ src/com/hehe/Classic/NumOfBinary_1.java	(date 1599475408280)
@@ -6,6 +6,8 @@
 /**
  * 有疑问！！！
  * -10 运行结果为30！！！！
+ *
+ * 进制的原因 32位
  */
 
 /**
Index: src/com/hehe/SortAndSearch/HeapSort01.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/hehe/SortAndSearch/HeapSort01.java	(date 1599046366044)
+++ src/com/hehe/SortAndSearch/HeapSort01.java	(date 1599046366044)
@@ -0,0 +1,45 @@
+package com.hehe.SortAndSearch;
+
+public class HeapSort01 {
+    public static void heapSort(int[] nums){
+        if (nums == null || nums.length < 2)
+            return;
+        for (int i = 0; i < nums.length; i++) {
+            heapInsert(nums,i);//构建大根堆
+        }
+        int size = nums.length;
+        //交换根节点和最后一个节点
+        swap(nums, 0, --size);
+        while (size > 0){
+            heapify(nums, 0, size);//调整
+            swap(nums, 0, --size);//交换
+        }
+    }
+    //根节点向下调整
+    private static void heapify(int[] nums, int i, int size) {
+        int left = 2*i+1;
+        while (left < size){//左孩子存在
+            int largest = left+1 < size && nums[left+1] > nums[left] ? left+1:left;
+            largest = nums[largest] > nums[i] ? largest : i;
+            if (largest == i)
+                break;
+            swap(nums,largest,i);
+            i=largest;
+            left = 2*i+1;
+        }
+    }
+
+    private static void heapInsert(int[] nums, int i) {
+        while (nums[i] > nums[(i-1)/2]){
+            //插入节点大于根节点
+            swap(nums,i,(i-1)/2);
+            i = (i-1)/2;
+        }
+    }
+
+    private static void swap(int[] nums, int i, int j) {
+        int tmp = nums[i];
+        nums[i] = nums[j];
+        nums[j] = tmp;
+    }
+}
Index: src/com/interview/T20200823_zijie1.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/interview/T20200823_zijie1.java	(date 1599046366029)
+++ src/com/interview/T20200823_zijie1.java	(date 1599046366029)
@@ -0,0 +1,63 @@
+package com.interview;
+
+import com.sun.xml.internal.ws.policy.privateutil.PolicyUtils;
+
+import java.security.spec.RSAOtherPrimeInfo;
+import java.util.*;
+
+/**
+ * 生成序列
+ */
+public class T20200823_zijie1 {
+    public static void main(String[] args) {
+        Scanner sc = new Scanner(System.in);
+        int n = sc.nextInt();
+        int l = sc.nextInt();
+        int r = sc.nextInt();
+
+        int[] arr = new int[r - l + 1];
+        int num = r - l + 1;
+        for (int i = 0; i < num; i++) {
+            arr[i] = l;
+            l++;
+        }
+
+        int count = 0;
+        int[] arr2 = Arrays.copyOf(arr, arr.length);
+        ArrayList<Integer> list = new ArrayList<>();
+        List<List<Integer>> llist = new ArrayList<>();
+        while (n >= 1) {
+            list.add(selectOne(arr2));
+            n--;
+        }
+        if(sumAll(arr2) % 3 == 0 && isOk(llist,list))
+            count++;
+        System.out.println(count);
+
+
+    }
+
+    private static boolean isOk(List<List<Integer>> llist, ArrayList<Integer> list) {
+
+
+        return false;
+    }
+
+    private static int sumAll(int[] arr) {
+        int sum = 0;
+        for (int i = 0; i < arr.length; i++)
+            sum+=arr[i];
+        return sum;
+    }
+
+    private static int selectOne(int[] arr) {
+        int res = 0;
+        for (int i = 0; i < arr.length; i++) {
+            if (arr[i] != -1){
+                res = arr[i];
+                break;
+            }
+        }
+        return res;
+    }
+}
Index: src/com/hehe/LinkedList/EntryNodeOfLoop.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/hehe/LinkedList/EntryNodeOfLoop.java	(date 1599481647755)
+++ src/com/hehe/LinkedList/EntryNodeOfLoop.java	(date 1599481647755)
@@ -0,0 +1,50 @@
+package com.hehe.LinkedList;
+
+import java.util.ArrayList;
+
+/**
+ * 两个结论：
+ * 1、设置快慢指针，假如有环，他们最后一定相遇。
+ * 2、两个指针分别从链表头和相遇点继续出发，每次走一步，最后一定相遇与环入口。
+ * 证明结论1：设置快慢指针fast和low，fast每次走两步，low每次走一步。假如有环，两者一定会相遇（因为low一旦进环，可看作fast在后面追赶low的过程，每次两者都接近一步，最后一定能追上）。
+ * 证明结论2：
+ * 设：
+ * 链表头到环入口长度为--a
+ * 环入口到相遇点长度为--b
+ * 相遇点到环入口长度为--c
+ * 则：相遇时
+ * 快指针路程=a+(b+c)k+b ，k>=1  其中b+c为环的长度，k为绕环的圈数（k>=1,即最少一圈，不能是0圈，不然和慢指针走的一样长，矛盾）。
+ * 慢指针路程=a+b
+ * 快指针走的路程是慢指针的两倍，所以：
+ * （a+b）*2=a+(b+c)k+b
+ * 化简可得：
+ * a=(k-1)(b+c)+c 这个式子的意思是： 链表头到环入口的距离=相遇点到环入口的距离+（k-1）圈环长度。其中k>=1,所以k-1>=0圈。所以两个指针分别从链表头和相遇点出发，最后一定相遇于环入口。
+ *
+ */
+public class EntryNodeOfLoop {
+    public static void main(String[] args) {
+
+
+    }
+
+    public static ListNode EntryNodeOfLoop(ListNode pHead){
+        ListNode p1 = pHead; //快指针
+        ListNode p2 = pHead; //慢指针
+
+        while(p1 != null && p1.next != null){
+            p1 = p1.next.next;
+            p2 = p2.next;
+            if(p1.val == p2.val)
+                break;
+        }
+        if(p1 == null || p1.next == null){  //若无环时 p1 或 p1.next会指向null
+            return null;
+        }
+        p1 = pHead;
+        while(p1.val != p2.val){
+            p1 = p1.next;
+            p2 = p2.next;
+        }
+        return p1;
+    }
+}
Index: src/com/hehe/RecursiveAndDynamic/Print_All_Permutations_zs.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.hehe.RecursiveAndDynamic;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.HashSet;\r\nimport java.util.List;\r\n\r\n/**\r\n * 递归\r\n * 打印 串 的所有排列组合\r\n * <p>\r\n * 将串中所有的位置上两两交换 就能得到全排列\r\n */\r\npublic class Print_All_Permutations_zs {\r\n    /**\r\n     * 串的所有排列组合 - ArrayList<String>\r\n     *\r\n     * @param str\r\n     * @return\r\n     */\r\n    public static ArrayList<String> Permutation(String str) {\r\n        List<String> res = new ArrayList<>();\r\n        if (str != null && str.length() > 0) {\r\n            PermutationHelper(str.toCharArray(), 0, res);\r\n            Collections.sort(res);\r\n        }\r\n        return (ArrayList) res;\r\n    }\r\n\r\n    public static void PermutationHelper(char[] cs, int i, List<String> list) {\r\n        if (i == cs.length - 1) {\r\n            String val = String.valueOf(cs);\r\n            if (!list.contains(val))\r\n                list.add(val);\r\n        }\r\n        for (int j = i; j < cs.length; j++) {\r\n            swap(cs, i, j);\r\n            PermutationHelper(cs, i + 1, list);\r\n            swap(cs, i, j);\r\n\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 串的所有排列组合 - void\r\n     *\r\n     * @param str\r\n     */\r\n    public static void printAllPermutations1(String str) {\r\n        char[] chs = str.toCharArray();\r\n        process1(chs, 0);\r\n    }\r\n\r\n    public static void process1(char[] chs, int i) {\r\n        if (i == chs.length) {\r\n            System.out.println(String.valueOf(chs));\r\n        }\r\n        for (int j = i; j < chs.length; j++) {\r\n            swap(chs, i, j);\r\n            process1(chs, i + 1);\r\n            swap(chs, i, j);\r\n        }\r\n    }\r\n\r\n    public static void swap(char[] chs, int i, int j) {\r\n        char tmp = chs[i];\r\n        chs[i] = chs[j];\r\n        chs[j] = tmp;\r\n    }\r\n\r\n    //===============================================未看=================================================\r\n    public static void printAllPermutations2(String str) {\r\n        char[] chs = str.toCharArray();\r\n        process2(chs, 0);\r\n    }\r\n\r\n    public static void process2(char[] chs, int i) {\r\n        if (i == chs.length) {\r\n            System.out.println(String.valueOf(chs));\r\n        }\r\n        HashSet<Character> set = new HashSet<>();\r\n        for (int j = i; j < chs.length; j++) {\r\n            if (!set.contains(chs[j])) {\r\n                set.add(chs[j]);\r\n                swap(chs, i, j);\r\n                process2(chs, i + 1);\r\n                swap(chs, i, j);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    public static void main(String[] args) {\r\n        String test1 = \"abc\";\r\n        printAllPermutations1(test1);\r\n        System.out.println(\"======\");\r\n//        printAllPermutations2(test1);\r\n//        System.out.println(\"======\");\r\n\r\n        String test2 = \"acc\";\r\n        printAllPermutations1(test2);\r\n        System.out.println(\"======\");\r\n//        printAllPermutations2(test2);\r\n//        System.out.println(\"======\");\r\n\r\n\r\n        System.out.println(\"===========================\");\r\n        List<String> list = Permutation(\"abc\");\r\n        for (String s : list) {\r\n            System.out.println(s);\r\n        }\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/hehe/RecursiveAndDynamic/Print_All_Permutations_zs.java	(revision 49a4e2ff04d1cdadecf01189b626421177ab47d2)
+++ src/com/hehe/RecursiveAndDynamic/Print_All_Permutations_zs.java	(date 1599452712861)
@@ -52,7 +52,7 @@
     }
 
     public static void process1(char[] chs, int i) {
-        if (i == chs.length) {
+        if (i == chs.length - 1) {
             System.out.println(String.valueOf(chs));
         }
         for (int j = i; j < chs.length; j++) {
Index: src/com/hehe/ProducerConsumer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/hehe/ProducerConsumer.java	(date 1599046366165)
+++ src/com/hehe/ProducerConsumer.java	(date 1599046366165)
@@ -0,0 +1,80 @@
+//package com.hehe;
+//
+//import java.util.concurrent.RecursiveTask;
+//
+//public class ProducerConsumer {
+//        private static BlockingQueue<String> queue = new ArrayBlockingQueue<>(5);
+//        private static class Producer extends Thread {
+//            @Override
+//            public void run() {
+//                try {
+//                    queue.put("product");
+//                } catch (InterruptedException e) {
+//                    e.printStackTrace();
+//                } S
+//                ystem.out.print("produce..");
+//            }
+//        } p
+//        rivate static class Consumer extends Thread {
+//            @Override
+//            public void run() {
+//                try {
+//                    String product = queue.take();
+//                } catch (InterruptedException e) {
+//                    e.printStackTrace();produce..produce..consume..consume..produce..consume..produce..consume..produce..consume.
+//.
+//                    ForkJoin
+//                    主要用于并行计算中，和 MapReduce 原理类似，都是把大的计算任务拆分成多个小任务并行计算。
+//                } S
+//                ystem.out.print("consume..");
+//            }
+//        }
+//    }
+//    ublic static void main(String[] args) {
+//        for (int i = 0; i < 2; i++) {
+//            Producer producer = new Producer();
+//            producer.start();
+//        } f
+//        or (int i = 0; i < 5; i++) {
+//            Consumer consumer = new Consumer();
+//            consumer.start();
+//        } f
+//        or (int i = 0; i < 3; i++) {
+//            Producer producer = new Producer();
+//            producer.start();
+//        }
+//    }
+//    public class ForkJoinExample extends RecursiveTask<Integer> {
+//        private final int threshold = 5;
+//        private int first;
+//        private int last;
+//        public ForkJoinExample(int first, int last) {
+//            this.first = first;
+//            this.last = last;
+//        }
+//        @Override
+//        protected Integer compute() {
+//            int result = 0;
+//            if (last - first <= threshold) {
+//// 任务足够小则直接计算
+//                for (int i = first; i <= last; i++) {
+//                    result += i;
+//                }
+//            } else {
+//// 拆分成小任务
+//                int middle = first + (last - first) / 2;
+////                ForkJoin 使用 ForkJoinPool 来启动，它是一个特殊的线程池，线程数量取决于 CPU 核数。
+////                ForkJoinPool 实现了工作窃取算法来提高 CPU 的利用率。每个线程都维护了一个双端队列，用来存储需要执行的
+////                任务。工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行。窃取的任务必须是最晚的任
+////                务，避免和队列所属线程发生竞争。例如下图中，Thread2 从 Thread1 的队列中拿出最晚的 Task1 任务，
+////                Thread1 会拿出 Task2 来执行，这样就避免发生竞争。但是如果队列中只有一个任务时还是会发生竞争。
+////                9. 线程不安全示例
+//                ForkJoinExample leftTask = new ForkJoinExample(first, middle);
+//                ForkJoinExample rightTask = new ForkJoinExample(middle + 1, last);
+//                leftTask.fork();
+//                rightTask.fork();
+//                result = leftTask.join() + rightTask.join();
+//            }
+//            return result;
+//        }
+//    }
Index: src/com/hehe/RecursiveAndDynamic/Print_All_Subsquences_zs.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.hehe.RecursiveAndDynamic;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.HashSet;\r\nimport java.util.List;\r\nimport java.util.Set;\r\n\r\n/**\r\n * 递归\r\n * 1、打印串、数组的全部子序列\r\n * 2、数组中数字任意组合 是否能得到一个给定值\r\n */\r\npublic class Print_All_Subsquences_zs {\r\n\r\n    public static void main(String[] args) {\r\n        //打印打印串、数组的全部子序列\r\n        String test = \"abc\";\r\n//        printAllSubsquence(test);\r\n        printAllSub(test.toCharArray(), 0, new String());\r\n\r\n\r\n        //数组中数字任意组合 是否能得到一个给定值\r\n//        int[] arr = {1,2,7,4};\r\n//        System.out.println(isSum01(arr,0,0,11));;\r\n    }\r\n\r\n    /**\r\n     * 打印数组的全部子序列（非子串，子串是连续的）\r\n     * @param chars\r\n     * @param i\r\n     * @param res\r\n     */\r\n    public static void printAllSub(char[] chars, int i, String res) {\r\n        if (i == chars.length) {\r\n            System.out.println(res);\r\n            return;  //返回类型是void的函数使用return语句是为了引起函数的强制结束，这种return的用法类似于循环结构中的break语句。\r\n        }\r\n        printAllSub(chars, i + 1, res);\r\n        printAllSub(chars, i + 1, res + String.valueOf(chars[i]));\r\n    }\r\n\r\n\r\n    private static boolean isSum01(int[] arr, int i, int sum, int aim) {\r\n        if (i == arr.length)\r\n            return sum == aim;\r\n        return isSum01(arr, i + 1, sum, aim) || isSum01(arr, i + 1, sum + arr[i], aim);\r\n\r\n    }\r\n\r\n    //===================================================未看=========================================================\r\n    public static void printAllSubsquence(String str) {\r\n        char[] chs = str.toCharArray();\r\n        process(chs, 0);\r\n    }\r\n\r\n    public static void process(char[] chs, int i) {\r\n        if (i == chs.length) {\r\n            System.out.println(String.valueOf(chs));\r\n            return;\r\n        }\r\n        process(chs, i + 1);\r\n        char tmp = chs[i];\r\n        chs[i] = 0;\r\n        process(chs, i + 1);\r\n        chs[i] = tmp;\r\n    }\r\n\r\n    public static void function(String str) {\r\n        char[] chs = str.toCharArray();\r\n        process(chs, 0, new ArrayList<Character>());\r\n    }\r\n\r\n    public static void process(char[] chs, int i, List<Character> res) {\r\n        if (i == chs.length) {\r\n            printList(res);\r\n        }\r\n        List<Character> resKeep = copyList(res);\r\n        resKeep.add(chs[i]);\r\n        process(chs, i + 1, resKeep);\r\n        List<Character> resNoInclude = copyList(res);\r\n        process(chs, i + 1, resNoInclude);\r\n    }\r\n\r\n    public static void printList(List<Character> res) {\r\n        // ...;\r\n    }\r\n\r\n    public static List<Character> copyList(List<Character> list) {\r\n        return null;\r\n    }\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/hehe/RecursiveAndDynamic/Print_All_Subsquences_zs.java	(revision 49a4e2ff04d1cdadecf01189b626421177ab47d2)
+++ src/com/hehe/RecursiveAndDynamic/Print_All_Subsquences_zs.java	(date 1599449378000)
@@ -36,7 +36,7 @@
             return;  //返回类型是void的函数使用return语句是为了引起函数的强制结束，这种return的用法类似于循环结构中的break语句。
         }
         printAllSub(chars, i + 1, res);
-        printAllSub(chars, i + 1, res + String.valueOf(chars[i]));
+        printAllSub(chars, i + 1, res +chars[i]);
     }
 
 
Index: src/com/hehe/Heap/PriorityQueueMedian.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/hehe/Heap/PriorityQueueMedian.java	(date 1599477734635)
+++ src/com/hehe/Heap/PriorityQueueMedian.java	(date 1599477734635)
@@ -0,0 +1,65 @@
+package com.hehe.Heap;
+
+import java.util.Comparator;
+import java.util.PriorityQueue;
+
+public class PriorityQueueMedian {
+    public static void main(String[] args) {
+
+        Insert(1);
+        System.out.println(GetMedian());
+        Insert(2);
+        System.out.println(GetMedian());
+        Insert(3);
+        System.out.println(GetMedian());
+        Insert(4);
+        System.out.println(GetMedian());
+        Insert(5);
+        System.out.println(GetMedian());
+        Insert(6);
+        System.out.println(GetMedian());
+        //Insert(7);
+//        System.out.println(GetMedian());
+    }
+
+    //小顶堆
+    private static PriorityQueue<Integer> minHeap = new PriorityQueue<Integer>();
+
+    //大顶堆
+    private static PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>(15, new Comparator<Integer>() {
+        @Override
+        public int compare(Integer o1, Integer o2) {
+            return o2 - o1;
+        }
+    });
+
+    //记录偶数个还是奇数个
+    static int  count = 0;
+    //每次插入小顶堆的是当前大顶堆中最大的数
+    //每次插入大顶堆的是当前小顶堆中最小的数
+    //这样保证小顶堆中的数永远大于等于大顶堆中的数
+    //中位数就可以方便地从两者的根结点中获取了
+    public static void Insert(Integer num) {
+        //个数为偶数的话，则先插入到大顶堆，然后将大顶堆中最大的数插入小顶堆中
+        if(count % 2 == 0){
+            maxHeap.offer(num);
+            int max = maxHeap.poll();
+            minHeap.offer(max);
+        }else{
+            //个数为奇数的话，则先插入到小顶堆，然后将小顶堆中最小的数插入大顶堆中
+            minHeap.offer(num);
+            int min = minHeap.poll();
+            maxHeap.offer(min);
+        }
+        count++;
+    }
+    public static Double GetMedian() {
+        //当前为偶数个，则取小顶堆和大顶堆的堆顶元素求平均
+        if(count % 2 == 0){
+            return new Double(minHeap.peek() + maxHeap.peek())/2;
+        }else{
+            //当前为奇数个，则直接从小顶堆中取元素即可
+            return new Double(minHeap.peek());
+        }
+    }
+}
Index: src/com/interview/T20200902_hw.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/interview/T20200902_hw.java	(date 1599050027191)
+++ src/com/interview/T20200902_hw.java	(date 1599050027191)
@@ -0,0 +1,25 @@
+package com.interview;
+
+import java.util.*;
+
+public class T20200902_hw {
+    public static void main(String[] args) {
+        Scanner sc = new Scanner(System.in);
+        Set<Integer> set = new HashSet<>();
+        TreeMap<Integer, Integer> map = new TreeMap<>(new Comparator<Integer>() {
+            @Override
+            public int compare(Integer o1, Integer o2) {
+                return o2 - o1;
+            }
+        });
+        Set<Integer> keySet = map.keySet();
+        int color = -1;
+        int num = 0;
+        for (int a : keySet){
+            int tmp =  map.get(a);
+            if(tmp == -1 || tmp == color)
+                num+=a;
+        }
+
+    }
+}
Index: src/com/interview/T20200717_niuke2.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/interview/T20200717_niuke2.java	(date 1599046365918)
+++ src/com/interview/T20200717_niuke2.java	(date 1599046365918)
@@ -0,0 +1,21 @@
+package com.interview;
+
+public class T20200717_niuke2 {
+    public static void main(String[] args) {
+
+
+    }
+
+    //【牛牛吃雪糕】最近天气太热了，牛牛每天都要吃雪糕。雪糕有一盒一份、一盒两份、一盒三份这三种包装，牛牛一天可以吃多盒雪糕，但是只能吃六份，吃多了就会肚子疼，吃少了就会中暑。
+    // 而且贪吃的牛牛一旦打开一盒雪糕，就一定会把它吃完。请问牛牛能健康地度过这段高温期么？
+    // 每个输入包含多个测试用例。输入的第一行包括一个正整数，表示数据组数T(1<=T<=100)。
+    // 接下来N行，每行包含四个正整数，表示高温期持续的天数N(1<=N<=10000)，一盒一份包装的雪糕数量A(1<=A<=100000)，一盒两份包装的雪糕数量B(1<=B<=100000)，一盒三份包装的雪糕数量C(1<=A<=100000)。
+    // 对于每个用例，在单独的一行中输出结果。如果牛牛可以健康地度过高温期则输出"Yes"，否则输出"No"。
+    // 4
+    // 1 1 1 1
+    // 2 0 0 4
+    // 3 0 2 5
+    // 4 24 0 0
+    // Yes Yes No Yes
+
+}
Index: src/com/hehe/Test/T1.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/hehe/Test/T1.java	(date 1599188385215)
+++ src/com/hehe/Test/T1.java	(date 1599188385215)
@@ -0,0 +1,13 @@
+package com.hehe.Test;
+
+public class T1 {
+    public static void main(String[] args) {
+        Integer i = 1,j = 1;
+        System.out.println(i == j);
+        System.out.println(i.equals(j));
+
+        Integer m = 200,n = 200;
+        System.out.println(m == n);
+        System.out.println(m.equals(n));
+    }
+}
Index: src/com/hehe/ArrayAndList/duplicate.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/hehe/ArrayAndList/duplicate.java	(date 1599536591456)
+++ src/com/hehe/ArrayAndList/duplicate.java	(date 1599536591456)
@@ -0,0 +1,35 @@
+package com.hehe.ArrayAndList;
+
+import java.util.Arrays;
+
+public class duplicate {
+    public static void main(String[] args) {
+        int[] numbers = {0,1,2,3,3,4};
+        System.out.println(duplicate(numbers));
+        for (int i = 0; i < numbers.length; i++) {
+            
+        }
+    }
+
+    public static int duplicate(int numbers[]) {
+        Arrays.sort(numbers);
+        int low = 0;
+        int high = numbers.length - 1;
+        int mid = 0;
+        while(low < high){
+            mid = (low + high)/2;
+            if (mid == numbers[mid]) {
+                low = mid + 1;
+            } else if (mid > numbers[mid] && mid == low  || mid > low && mid - 1 == numbers[mid - 1]) {
+//                high = mid - 1;
+                return mid  -1;
+            } else {
+                high = mid - 1;
+            }
+        }
+        return -1;
+    }
+
+
+
+}
Index: src/com/hehe/RecursiveAndDynamic/JumpFloor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.hehe.RecursiveAndDynamic;\r\n\r\npublic class JumpFloor {\r\n    public static void main(String[] args) {\r\n        //比较倾向于找规律的解法，f(1) = 1, f(2) = 2, f(3) = 3, f(4) = 5，  可以总结出f(n) = f(n-1) + f(n-2)的规律，但是为什么会出现这样的规律呢？\r\n        // 假设现在6个台阶，我们可以从第5跳一步到6，这样的话有多少种方案跳到5就有多少种方案跳到6，另外我们也可以从4跳两步跳到6，跳到4有多少种方案的话，就有多少种方案跳到6，\r\n        // 其他的不能从3跳到6什么的啦，所以最后就是f(6) = f(5) + f(4)；这样子也很好理解变态跳台阶的问题了\r\n        System.out.println(jumpFloor(3));\r\n        System.out.println(jumpFloorII(3));\r\n\r\n    }\r\n\r\n    /**\r\n     * 初级跳台阶\r\n     * @param n\r\n     * @return\r\n     */\r\n    public static long jumpFloor(int n){\r\n        if(n<=0)\r\n            return 0;\r\n        if(n<=2)\r\n            return n;\r\n        long[] f = {1,2,0};\r\n        for (int i = 2; i < n; i++) {\r\n            f[2] = f[1] + f[0];\r\n            f[0] = f[1];\r\n            f[1] = f[2];\r\n        }\r\n        return f[2];\r\n    }\r\n\r\n\r\n    //f(n-1) = f(0) + f(1)+f(2)+f(3) + ... + f((n-1)-1) = f(0) + f(1) + f(2) + f(3) + ... + f(n-2)\r\n    //f(n) = f(0) + f(1) + f(2) + f(3) + ... + f(n-2) + f(n-1) = f(n-1) + f(n-1)\r\n    // 可以得出：\r\n    // f(n) = 2*f(n-1)\r\n\r\n    /**\r\n     * 变态跳台阶\r\n     * @param target\r\n     * @return\r\n     */\r\n    public static int jumpFloorII(int target) {\r\n\r\n        return 1<<(target-1);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/hehe/RecursiveAndDynamic/JumpFloor.java	(revision 49a4e2ff04d1cdadecf01189b626421177ab47d2)
+++ src/com/hehe/RecursiveAndDynamic/JumpFloor.java	(date 1599461254070)
@@ -1,5 +1,7 @@
 package com.hehe.RecursiveAndDynamic;
 
+import java.util.ArrayList;
+
 public class JumpFloor {
     public static void main(String[] args) {
         //比较倾向于找规律的解法，f(1) = 1, f(2) = 2, f(3) = 3, f(4) = 5，  可以总结出f(n) = f(n-1) + f(n-2)的规律，但是为什么会出现这样的规律呢？
@@ -8,6 +10,9 @@
         System.out.println(jumpFloor(3));
         System.out.println(jumpFloorII(3));
 
+        System.out.println(jumpFloorIII(10));
+        System.out.println(jumpFloorIIII(10));
+
     }
 
     /**
@@ -44,4 +49,48 @@
 
         return 1<<(target-1);
     }
+
+    /**
+     * 跳台阶 每次一步或者两步 且要求不能有连续的两步
+     * @param n
+     * @return
+     */
+    public static int jumpFloorIII(int n){
+        if(n <= 4)
+            return n;
+        int[] arr= {1,2,3,4};
+        while(n > 0){
+            int tmp = arr[0] + arr[1] + arr[2];
+            arr[0] = arr[1];
+            arr[1] = arr[2];
+            arr[2] = arr[3];
+            arr[3] = tmp;
+            n -= 1;
+        }
+        return arr[3];
+    }
+
+    /**
+     * 复杂度高 没通过字节的笔试
+     * @param n
+     * @return
+     */
+    public static int jumpFloorIIII(int n){
+        if(n <= 4)
+            return n;
+        ArrayList<Integer> list = new ArrayList<>();
+        list.add(1);
+        list.add(2);
+        list.add(3);
+        list.add(4);
+        int size = 0;
+        while(n > 0){
+            size = list.size();
+            int tmp = list.get(size-2) + list.get(size-3) + list.get(size -4);
+            list.add(tmp);
+            n -= 1;
+        }
+        return list.get(list.size() - 1);
+    }
+
 }
