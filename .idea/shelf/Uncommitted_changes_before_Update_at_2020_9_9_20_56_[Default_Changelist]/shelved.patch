Index: src/com/hehe/ArrayAndList/get3Num.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.hehe.ArrayAndList;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.List;\r\n\r\n/*输出数组中三个数字之和等于0，的所有组合\r\n *\r\n *\r\n * */\r\npublic class get3Num {\r\n\r\n    public static List<List<Integer>> threeSum(int[] nums) {\r\n        //给定数组排序\r\n        Arrays.sort(nums);\r\n        for (int i = 0; i <nums.length ; i++) {\r\n            System.out.print(nums[i]+\" \");\r\n        }\r\n        List<List<Integer>> allList = new ArrayList<>();\r\n\r\n        //设i为start指针与end指针的和 --的相反数\r\n        for (int i = 0; i < nums.length - 2; ) { //i++ 一个一个自增 会有重复的序列 故需要特殊处理\r\n            //start指针对应起始位置\r\n            int start = i + 1;\r\n            //end指针对应结束位置\r\n            int end = nums.length - 1;\r\n            while (start < end) {\r\n                if (nums[start] + nums[end] == -nums[i]) {   //同 ：nums[start] + nums[end] +nums[i] == 0\r\n                    List<Integer> list = new ArrayList<>(3);\r\n                    list.add(nums[i]);\r\n                    list.add(nums[start]);\r\n                    list.add(nums[end]);\r\n                    allList.add(list);\r\n                    start++;\r\n                    end--;\r\n                    //除去end指针的重复值(是否和上一个相同)\r\n                    while (nums[end] == nums[end + 1] && start < end) {\r\n                        end--;\r\n                    }\r\n                    //除去start指针的重复值\r\n                    while (nums[start] == nums[start - 1] && start < end) {\r\n                        start++;\r\n                    }\r\n                } else if (nums[start] + nums[end] > -nums[i]) { //3值的和大于0时，重新检测end指针是否重复后降值\r\n                    end--;\r\n                    while (nums[end] == nums[end + 1] && start < end) {\r\n                        end--;\r\n                    }\r\n                } else {//3值的和小于0时，重新检测start指针是否重复后升值\r\n                    start++;\r\n                    while (nums[start] == nums[start - 1] && start < end) {\r\n                        start++;\r\n                    }\r\n                }\r\n            }\r\n            i++; //特殊处理i 将重复序列去掉\r\n            while (nums[i] == nums[i - 1] && i < nums.length - 2) {\r\n                i++;\r\n            }\r\n        }\r\n        return allList;\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        int nums[] = {-4, -2, 1, 0, 0, -2, 3, 1, -5, 0};\r\n\r\n        List<List<Integer>> ends = threeSum(nums);\r\n        for (List<Integer> i : ends) {\r\n            System.out.println(i);\r\n        }\r\n    }\r\n\r\n}\r\n\r\n/* ArrayList 难度：***\r\n *\r\n * java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。\r\n\t\t具有以下功能：\r\n\t\t给数组赋值：通过 fill 方法。\r\n\t\t对数组排序：通过 sort 方法,按升序。\r\n\t\t比较数组：通过 equals 方法比较数组中元素值是否相等。\r\n\t\t查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。\r\n *\r\n * */\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/hehe/ArrayAndList/get3Num.java	(revision 9403cf75b8fc73c838fe62523147b973d3cf4796)
+++ src/com/hehe/ArrayAndList/get3Num.java	(date 1599632169829)
@@ -4,18 +4,78 @@
 import java.util.Arrays;
 import java.util.List;
 
-/*输出数组中三个数字之和等于0，的所有组合
+/*1、输出数组中三个数字之和等于0，的所有组合
  *
- *
+ *2、输出数组中四个数字之和等于0，的所有组合
  * */
 public class get3Num {
 
+    /**
+     * 输出数组中四个数字之和等于0，的所有组合
+     * @param nums
+     * @param target
+     * @return
+     */
+    public static List<List<Integer>> fourSum(int[] nums,int target) {
+        Arrays.sort(nums);
+        List<List<Integer>> allList = new ArrayList<>();
+        if(nums.length < 4)
+            return allList;
+        for (int i = 0; i < nums.length - 3; i++) {
+            if(i > 0 && nums[i] == nums[i-1])
+                continue;
+            for (int j = i + 1; j < nums.length - 2;j++) {
+                if(j > i+1 && nums[j] == nums[j-1])
+                    continue;;
+
+                int start = j + 1;
+                int end = nums.length - 1;
+                while (start < end) {
+                    if(nums[i] + nums[j] +nums[start] + nums[end] == target ){
+                        List<Integer> list = new ArrayList<>();
+                        list.add(nums[i]);
+                        list.add(nums[j]);
+                        list.add(nums[start]);
+                        list.add(nums[end]);
+                        allList.add(list);
+                        start++;
+                        end--;
+                        while(start< end && nums[start] == nums[start-1]){
+                            start++;
+                        }
+                        while (nums[end] == nums[end + 1] && start < end) {
+                            end--;
+                        }
+
+                    }else if(nums[i] + nums[j] +nums[start] + nums[end] < target){
+                        start++;
+                        while (nums[start] == nums[start - 1] && start < nums.length - 1) {
+                            start++;
+                        }
+                    }else{
+                        end--;
+                        while (nums[end] == nums[end + 1] && end > 3) {
+                            end--;
+                        }
+                    }
+                }
+            }
+        }
+        return allList;
+    }
+
+    /**
+     * 输出数组中三个数字之和等于0，的所有组合
+     *
+     * @param nums
+     * @return
+     */
     public static List<List<Integer>> threeSum(int[] nums) {
         //给定数组排序
         Arrays.sort(nums);
-        for (int i = 0; i <nums.length ; i++) {
-            System.out.print(nums[i]+" ");
-        }
+//        for (int i = 0; i <nums.length ; i++) {
+//            System.out.print(nums[i]+" ");
+//        }
         List<List<Integer>> allList = new ArrayList<>();
 
         //设i为start指针与end指针的和 --的相反数
Index: src/com/hehe/Classic/Z_ShapeChange.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.hehe.Classic;\r\n/*题目描述：Z字形排列变换\r\n * 将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。\r\n * Z字形排列：\r\n *\r\n * L   C   I   R\r\n   E T O E S I I G\r\n   E   D   H   N\r\n *\r\n * 示例 1:\r\n\r\n\t输入: s = \"LEETCODEISHIRING\", numRows = 3\r\n\t输出: \"LCIRETOESIIGEDHN\"\r\n   示例 2:\r\n\r\n\t输入: s = \"LEETCODEISHIRING\", numRows = 4\r\n\t输出: \"LDREOEIIECIHNTSG\"\r\n *\r\n * L     D     R\r\n   E   O E   I I\r\n   E C   I H   N\r\n   T     S     G\r\n * */\r\n\r\npublic class Z_ShapeChange {\r\n\r\n    public static void main(String[] args) {\r\n        String s =\"LEETCODEISHIRING\";\r\n        int numRows = 3;\r\n        String ret = convert(s, numRows);\r\n        System.out.println(ret);\r\n\r\n    }\r\n\r\n    /**\r\n     * 将之字形字符串按行打印出来\r\n     * @param s\r\n     * @param numRows\r\n     * @return\r\n     */\r\n    public static String convert(String s, int numRows) {\r\n\r\n        if (numRows == 1) return s;\r\n\r\n        StringBuilder ret = new StringBuilder();\r\n        int n = s.length();\r\n        //循环长度：\r\n        int cycleLen = 2 * numRows - 2;\r\n\r\n        //按行访问\r\n        for (int i = 0; i < numRows; i++) {\r\n            for (int j = 0; j + i < n; j += cycleLen) {\r\n\r\n                ret.append(s.charAt(j + i));\r\n                //非第一行和非最后一行时 s 的下标\r\n                if (i != 0 && i != numRows - 1 && j + cycleLen - i < n)\r\n                    ret.append(s.charAt(j + cycleLen - i));\r\n            }\r\n        }\r\n        return ret.toString();\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/hehe/Classic/Z_ShapeChange.java	(revision 9403cf75b8fc73c838fe62523147b973d3cf4796)
+++ src/com/hehe/Classic/Z_ShapeChange.java	(date 1599568906317)
@@ -22,6 +22,9 @@
    T     S     G
  * */
 
+import java.util.ArrayList;
+import java.util.List;
+
 public class Z_ShapeChange {
 
     public static void main(String[] args) {
@@ -60,4 +63,25 @@
         return ret.toString();
     }
 
+    public String convert01(String s, int numRows) {
+        if(numRows < 2)
+            return s;
+        List<StringBuilder> rows = new ArrayList<StringBuilder>();
+
+        for(int i = 0; i < numRows; i++)
+            rows.add(new StringBuilder());
+
+        int i = 0, flag = -1;
+        for(char c : s.toCharArray()) {
+            rows.get(i).append(c);
+            if(i == 0 || i == numRows -1)
+                flag = - flag;
+            i += flag;
+        }
+        StringBuilder res = new StringBuilder();
+        for(StringBuilder row : rows) res.append(row);
+        return res.toString();
+    }
+
+
 }
Index: src/com/hehe/Classic/GenerateParenthesis.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/hehe/Classic/GenerateParenthesis.java	(date 1599643397566)
+++ src/com/hehe/Classic/GenerateParenthesis.java	(date 1599643397566)
@@ -0,0 +1,76 @@
+package com.hehe.Classic;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * 输入 n
+ * 输出 n 对 括号的所有有效序列
+ */
+public class GenerateParenthesis {
+
+    public List<String> generateParenthesis(int n) {
+        List<String> list = new ArrayList<>();
+        StringBuilder sb = new StringBuilder();
+        if (n == 0)
+            return list;
+
+        generateCore(list, n, n, "");
+        return list;
+    }
+
+    private void generateCore(List<String> list, int left, int right, String curStr) {
+        if (left == 0 && right == 0) {
+            list.add(curStr);
+            return;
+        }
+        if (left > right)  //已经有的字符串序列 左括号剩余一定要比右括号少 否则不是有效括号序列
+            return;
+        if (left > 0)
+            generateCore(list, left - 1, right, curStr + "(");
+        if (right > 0)
+            generateCore(list, left, right - 1, curStr + ")");
+    }
+
+
+    /**
+     * 另一种思路
+     * @param n
+     * @return
+     */
+    public List<String> generateParenthesis01(int n) {
+        List<String> res = new ArrayList<>();
+        if (n == 0) {
+            return res;
+        }
+
+        StringBuilder path = new StringBuilder();
+        dfs(path, n, n, res);
+        return res;
+    }
+
+    private void dfs(StringBuilder path, int left, int right, List<String> res) {
+        if (left == 0 && right == 0) {
+            // path.toString() 生成了一个新的字符串，相当于做了一次拷贝，这里的做法等同于「力扣」第 46 题、第 39 题
+            res.add(path.toString());
+            return;
+        }
+
+        // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节）
+        if (left > right) {
+            return;
+        }
+
+        if (left > 0) {
+            path.append("(");
+            dfs(path, left - 1, right, res);
+            path.deleteCharAt(path.length() - 1); //path 在给别的分支回溯需要删除 最后一个字符
+        }
+
+        if (right > 0) {
+            path.append(")");
+            dfs(path, left, right - 1, res);
+            path.deleteCharAt(path.length() - 1);
+        }
+    }
+}
Index: src/com/hehe/Classic/nextPermutation.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/hehe/Classic/nextPermutation.java	(date 1599640203972)
+++ src/com/hehe/Classic/nextPermutation.java	(date 1599640203972)
@@ -0,0 +1,34 @@
+package com.hehe.Classic;
+
+import java.util.Arrays;
+
+public class nextPermutation {
+    public static void main(String[] args) {
+        int[] nums = {1,2,3};
+        nextPermutation(nums);
+        for(int c : nums){
+            System.out.print(c + " ");
+        }
+    }
+
+
+    public static void nextPermutation(int[] nums) {
+        boolean b = false;
+        for (int i = nums.length - 1; i > 0 ; i--) {
+            if(b)
+                break;
+            for (int j = i - 1; j >= 0 ; j--) {
+                if(nums[j] < nums[i]){
+                    int tmp = nums[i];
+                    nums[i] = nums[j];
+                    nums[j] = tmp;
+                    b = true;
+                    break;
+                }
+
+                if(i == 1 && j== 0 && nums[j] >= nums[i])
+                    Arrays.sort(nums);
+            }
+        }
+    }
+}
Index: src/com/hehe/String/RegularMatch.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.hehe.String;\r\n\r\n\r\n\r\n/**\r\n *请实现一个函数用来匹配包含'. '和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。\r\n * 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串\"aaa\"与模式\"a.a\"和\"ab*ac*a\"匹配，但与\"aa.a\"和\"ab*a\"均不匹配。\r\n *\r\n */\r\npublic class RegularMatch {\r\n    public static void main(String[] args) {\r\n//        System.out.println(isMatch(\"aaa\", \"a.a\"));\r\n//        System.out.println(isMatch(\"aaa\", \"ab*ac*a\"));\r\n//        System.out.println(isMatch(\"aaa\", \"aa.a\"));\r\n//        System.out.println(isMatch(\"aaa\", \"ab*a\"));\r\n//        System.out.println(isMatch(\"aaa\", \".*\"));\r\n\r\n//        true\r\n//        true\r\n//        false\r\n//        false\r\n//        true\r\n\r\n        System.out.println(match(\"aaa\".toCharArray(), \"a.a\".toCharArray()));\r\n        System.out.println(match(\"aaa\".toCharArray(), \"ab*ac*a\".toCharArray()));\r\n        System.out.println(match(\"aaa\".toCharArray(), \"aa.a\".toCharArray()));\r\n        System.out.println(match(\"aaa\".toCharArray(), \"ab*a\".toCharArray()));\r\n        System.out.println(match(\"aaa\".toCharArray(), \".*\".toCharArray()));\r\n\r\n    }\r\n\r\n    public static boolean match(char[] str, char[] pattern) {\r\n        if (str == null || pattern == null) {\r\n            return false;\r\n        }\r\n        int strIndex = 0;\r\n        int patternIndex = 0;\r\n        return matchCore(str, strIndex, pattern, patternIndex);\r\n    }\r\n\r\n    public static boolean matchCore(char[] str, int strIndex, char[] pattern, int patternIndex) {\r\n        //有效性检验：str到尾，pattern到尾，匹配成功\r\n        if (strIndex == str.length && patternIndex == pattern.length) {\r\n            return true;\r\n        }\r\n        //pattern先到尾，匹配失败\r\n        if (strIndex != str.length && patternIndex == pattern.length) {\r\n            return false;\r\n        }\r\n        //模式第2个是*，且字符串第1个跟模式第1个匹配,分3种匹配模式；如不匹配，模式后移2位\r\n        if (patternIndex + 1 < pattern.length && pattern[patternIndex + 1] == '*') {\r\n            if ((strIndex != str.length && pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == '.' && strIndex != str.length)) {\r\n                return matchCore(str, strIndex, pattern, patternIndex + 2)//模式后移2，视为x*匹配0个字符\r\n                        || matchCore(str, strIndex + 1, pattern, patternIndex + 2)//视为模式匹配1个字符\r\n                        || matchCore(str, strIndex + 1, pattern, patternIndex);//*匹配1个，再匹配str中的下一个\r\n            } else {\r\n                return matchCore(str, strIndex, pattern, patternIndex + 2);\r\n            }\r\n        }\r\n        //模式第2个不是*，且字符串第1个跟模式第1个匹配，则都后移1位，否则直接返回false\r\n        if ((strIndex != str.length && pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == '.' && strIndex != str.length)) {\r\n            return matchCore(str, strIndex + 1, pattern, patternIndex + 1);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    static boolean isMatch(String str, String patten) {\r\n        if (str.isEmpty() && patten.isEmpty())\r\n            return true;\r\n        return MatchCore(str, patten);\r\n    }\r\n\r\n\r\n    private static boolean MatchCore(String str, String patten) {\r\n        if (str.isEmpty())\r\n            return patten.isEmpty();\r\n        if(patten.isEmpty())\r\n            return str.isEmpty();\r\n\r\n        if (patten.length() > 1 && patten.charAt(1) == '*' && str.length() >= 1) { //patten 至少为 q*样子\r\n\r\n            if (str.charAt(0) == patten.charAt(0) || patten.charAt(0) == '.')\r\n                return MatchCore(str, patten.substring(2)) //patten后面可能有 x* 去匹配 0+ 个str中的字符\r\n                        || MatchCore(str.substring(1), patten)\r\n                        || MatchCore(str.substring(1), patten.substring(2));\r\n            else\r\n                return MatchCore(str, patten.substring(2));\r\n        }\r\n        if ((str.charAt(0) == patten.charAt(0) && str.length() >= 1 && patten.length() >= 1)\r\n                || (patten.charAt(0) == '.' && str.length() >= 1))\r\n            return MatchCore(str.substring(1), patten.substring(1));\r\n        return false;\r\n\r\n    }\r\n\r\n\r\n    public boolean isMatch01(String s, String p) {\r\n        //如果正则串p为空字符串s也为空这匹配成功，如果正则串p为空但是s不是空则说明匹配失败\r\n        if (p.isEmpty()) return s.isEmpty();\r\n        //判断s和p的首字符是否匹配，注意要先判断s不为空\r\n        boolean headMatched = !s.isEmpty() && (s.charAt(0) == p.charAt(0) || p.charAt(0) == '.');\r\n        if (p.length() >= 2 && p.charAt(1) == '*') {//如果p的第一个元素的下一个元素是*\r\n            //则分别对两种情况进行判断\r\n            return isMatch01(s, p.substring(2)) ||\r\n                    (headMatched && isMatch(s.substring(1), p));\r\n        } else if (headMatched) {//否则，如果s和p的首字符相等\r\n            return isMatch01(s.substring(1), p.substring(1));\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/hehe/String/RegularMatch.java	(revision 9403cf75b8fc73c838fe62523147b973d3cf4796)
+++ src/com/hehe/String/RegularMatch.java	(date 1599570352750)
@@ -14,6 +14,9 @@
 //        System.out.println(isMatch("aaa", "aa.a"));
 //        System.out.println(isMatch("aaa", "ab*a"));
 //        System.out.println(isMatch("aaa", ".*"));
+        System.out.println(isMatch("a", "ab*"));
+        System.out.println(isMatch("ab", ".*c"));
+        System.out.println("=====================");
 
 //        true
 //        true
@@ -72,25 +75,25 @@
 
 
     private static boolean MatchCore(String str, String patten) {
-        if (str.isEmpty())
-            return patten.isEmpty();
-        if(patten.isEmpty())
-            return str.isEmpty();
+            if (str.isEmpty() && patten.isEmpty())
+                return true;
+            if(!str.isEmpty() && patten.isEmpty())
+                return str.isEmpty();
 
-        if (patten.length() > 1 && patten.charAt(1) == '*' && str.length() >= 1) { //patten 至少为 q*样子
+        if (patten.length() > 1 && patten.charAt(1) == '*' ) { //patten 至少为 q*样子
 
-            if (str.charAt(0) == patten.charAt(0) || patten.charAt(0) == '.')
+            if (str.length() > 0 && str.charAt(0) == patten.charAt(0) || patten.charAt(0) == '.' && str.length() > 0)
                 return MatchCore(str, patten.substring(2)) //patten后面可能有 x* 去匹配 0+ 个str中的字符
                         || MatchCore(str.substring(1), patten)
                         || MatchCore(str.substring(1), patten.substring(2));
             else
                 return MatchCore(str, patten.substring(2));
         }
-        if ((str.charAt(0) == patten.charAt(0) && str.length() >= 1 && patten.length() >= 1)
-                || (patten.charAt(0) == '.' && str.length() >= 1))
+        if (str.length() >= 1 && patten.length() >= 1 && (str.charAt(0) == patten.charAt(0))
+                || (patten.charAt(0) == '.' && str.length() >= 1 && patten.length() >= 1))
             return MatchCore(str.substring(1), patten.substring(1));
-        return false;
-
+        else
+            return false;
     }
 
 
Index: src/com/hehe/RecursiveAndDynamic/PathIn2Arr.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/hehe/RecursiveAndDynamic/PathIn2Arr.java	(date 1599642851006)
+++ src/com/hehe/RecursiveAndDynamic/PathIn2Arr.java	(date 1599642851006)
@@ -0,0 +1,42 @@
+package com.hehe.RecursiveAndDynamic;
+
+import java.util.HashSet;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Set;
+
+public class PathIn2Arr {
+    Set<List<Integer>> res = new HashSet<>();
+    public Set<List<Integer>> path(boolean[][] map, int x, int y){
+        int count = 0;
+        for (int i = 0; i < map.length; i++) {
+            for (int j = 0; j < map[0].length; j++) {
+                if(map[i][j] == true)
+                    count++;
+            }
+        }
+        dfs(map,x,y,count);
+        return res;
+    }
+
+    private boolean dfs(boolean[][] map, int x, int y, int count) {
+        if(x < 0 || y < 0 || x >= map.length || y >= map[0].length
+                || map[x][y] == false){
+            return false;}
+        if (res.size() == count)
+            return true;
+        List<Integer> path = new LinkedList<>();
+        path.add(x);
+        path.add(y);
+        if(res.contains(path))
+            return false;
+        res.add(path);
+        if(dfs(map,x-1,y,count) || dfs(map,x+1,y,count)||
+                dfs(map,x,y-1,count)|| dfs(map,x,y+1,count))
+            return true;
+        else {
+            res.clear();
+            return false;
+        }
+    }
+}
Index: src/com/interview/T20200823_zijie1.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/interview/T20200823_zijie1.java	(date 1599566185164)
+++ src/com/interview/T20200823_zijie1.java	(date 1599566185164)
@@ -0,0 +1,63 @@
+package com.interview;
+
+import com.sun.xml.internal.ws.policy.privateutil.PolicyUtils;
+
+import java.security.spec.RSAOtherPrimeInfo;
+import java.util.*;
+
+/**
+ * 生成序列
+ */
+public class T20200823_zijie1 {
+    public static void main(String[] args) {
+        Scanner sc = new Scanner(System.in);
+        int n = sc.nextInt();
+        int l = sc.nextInt();
+        int r = sc.nextInt();
+
+        int[] arr = new int[r - l + 1];
+        int num = r - l + 1;
+        for (int i = 0; i < num; i++) {
+            arr[i] = l;
+            l++;
+        }
+
+        int count = 0;
+        int[] arr2 = Arrays.copyOf(arr, arr.length);
+        ArrayList<Integer> list = new ArrayList<>();
+        List<List<Integer>> llist = new ArrayList<>();
+        while (n >= 1) {
+            list.add(selectOne(arr2));
+            n--;
+        }
+        if(sumAll(arr2) % 3 == 0 && isOk(llist,list))
+            count++;
+        System.out.println(count);
+
+
+    }
+
+    private static boolean isOk(List<List<Integer>> llist, ArrayList<Integer> list) {
+
+
+        return false;
+    }
+
+    private static int sumAll(int[] arr) {
+        int sum = 0;
+        for (int i = 0; i < arr.length; i++)
+            sum+=arr[i];
+        return sum;
+    }
+
+    private static int selectOne(int[] arr) {
+        int res = 0;
+        for (int i = 0; i < arr.length; i++) {
+            if (arr[i] != -1){
+                res = arr[i];
+                break;
+            }
+        }
+        return res;
+    }
+}
Index: src/com/hehe/Test/T1.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/hehe/Test/T1.java	(date 1599566185323)
+++ src/com/hehe/Test/T1.java	(date 1599566185323)
@@ -0,0 +1,13 @@
+package com.hehe.Test;
+
+public class T1 {
+    public static void main(String[] args) {
+        Integer i = 1,j = 1;
+        System.out.println(i == j);
+        System.out.println(i.equals(j));
+
+        Integer m = 200,n = 200;
+        System.out.println(m == n);
+        System.out.println(m.equals(n));
+    }
+}
Index: src/com/interview/T20200717_niuke2.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/interview/T20200717_niuke2.java	(date 1599566185338)
+++ src/com/interview/T20200717_niuke2.java	(date 1599566185338)
@@ -0,0 +1,21 @@
+package com.interview;
+
+public class T20200717_niuke2 {
+    public static void main(String[] args) {
+
+
+    }
+
+    //【牛牛吃雪糕】最近天气太热了，牛牛每天都要吃雪糕。雪糕有一盒一份、一盒两份、一盒三份这三种包装，牛牛一天可以吃多盒雪糕，但是只能吃六份，吃多了就会肚子疼，吃少了就会中暑。
+    // 而且贪吃的牛牛一旦打开一盒雪糕，就一定会把它吃完。请问牛牛能健康地度过这段高温期么？
+    // 每个输入包含多个测试用例。输入的第一行包括一个正整数，表示数据组数T(1<=T<=100)。
+    // 接下来N行，每行包含四个正整数，表示高温期持续的天数N(1<=N<=10000)，一盒一份包装的雪糕数量A(1<=A<=100000)，一盒两份包装的雪糕数量B(1<=B<=100000)，一盒三份包装的雪糕数量C(1<=A<=100000)。
+    // 对于每个用例，在单独的一行中输出结果。如果牛牛可以健康地度过高温期则输出"Yes"，否则输出"No"。
+    // 4
+    // 1 1 1 1
+    // 2 0 0 4
+    // 3 0 2 5
+    // 4 24 0 0
+    // Yes Yes No Yes
+
+}
