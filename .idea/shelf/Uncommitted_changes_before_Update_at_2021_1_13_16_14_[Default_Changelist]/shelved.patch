Index: src/com/hehe/ArrayAndList/ArrayQs.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.hehe.ArrayAndList;\r\n\r\npublic class ArrayQs {\r\n\r\n    public static void main(String[] args) {\r\n\r\n        int[] arr = {1,2,3,4,5};\r\n        int[] newArr = reOrderArray(arr);\r\n        int[] res = sortArrayByParity(arr);\r\n        for(int i : newArr){\r\n            System.out.print(i + \" \");\r\n        }\r\n        for(int i : res){\r\n            System.out.print(i + \" \");\r\n        }\r\n        int[] nums = {1, 1, 2, 2};\r\n        System.out.println(removeDuplicates(nums));\r\n\r\n        int[] remove = {1,3,4,5,-1,0,-3};\r\n        System.out.println(findRemoveIndex(remove));\r\n    }\r\n\r\n\r\n    /**\r\n     * 按奇偶排序数组\r\n     * @param A\r\n     * @return\r\n     */\r\n    public static int[] sortArrayByParity(int[] A) {\r\n        int i = 0;\r\n        int j = A.length - 1;\r\n        while (i < j) {\r\n            if (A[i] % 2 > A[j] % 2) { //A[i] % 2 == 1 &&  A[j] % 2 == 0\r\n                int tmp = A[i];\r\n                A[i] = A[j];\r\n                A[j] = tmp;\r\n            }\r\n            while (i < A.length && A[i] % 2 == 0)\r\n                i++;\r\n            while (j > 0 && A[j] % 2 == 1)\r\n                j--;\r\n        }\r\n        return A;\r\n    }\r\n\r\n    /**\r\n     * 按奇偶排序数组 --辅助数组返回 不改变相对顺序\r\n     *\r\n     * @param array\r\n     * @return\r\n     */\r\n    public static int[] reOrderArray(int[] array) {\r\n        if (array.length == 0 || array == null)\r\n            return new int[]{};\r\n        int[] newArray = new int[array.length];\r\n        int len = array.length;\r\n        int k = 0;\r\n        for (int i = 0; i < len; i++) {\r\n            if(array[i] % 2 == 1){\r\n                newArray[k++] = array[i];\r\n            }\r\n        }\r\n        for (int i = 0; i < len; i++) {\r\n            if(array[i] % 2 == 0){\r\n                newArray[k++] = array[i];\r\n            }\r\n        }\r\n        return newArray;\r\n    }\r\n\r\n    /**\r\n     * 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\r\n     *\r\n     * @param nums\r\n     */\r\n    public void moveZeroes(int[] nums) {\r\n        int j = 0;\r\n        for (int i = 0; i < nums.length; i++) {\r\n            if (nums[i] != 0)\r\n                nums[j++] = nums[i];\r\n        }\r\n        for (int i = j; i < nums.length; i++) {\r\n            nums[i] = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 移除重复数字\r\n     *\r\n     * 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。\r\n     * 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。\r\n     * 示例 1:\r\n     * 给定数组 nums = [1,1,2],\r\n     * 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。\r\n     * 你不需要考虑数组中超出新长度后面的元素。\r\n     * @param nums\r\n     * @return\r\n     */\r\n    public static int removeDuplicates(int[] nums) {\r\n        int len = nums.length;\r\n        if (len == 0)\r\n            return 0;\r\n\r\n        int value = nums[0];\r\n        int index = 0;\r\n        for (int i = 1; i < nums.length; i++) {\r\n            if (nums[i] != value) {\r\n                nums[++index] = nums[i];\r\n                value = nums[i];\r\n            } else {\r\n                len--;\r\n            }\r\n        }\r\n        return len;\r\n\r\n\r\n    }\r\n\r\n    /**\r\n     * 删除数组(有正有负)的一个数 使其它的数字乘积最大\r\n     * 分情况讨论\r\n     * @param nums\r\n     * @return\r\n     */\r\n    public static int findRemoveIndex(int[] nums) {\r\n\r\n        // 统计负数的个数\r\n        int negativeCount = 0;\r\n        for (int i = 0; i < nums.length; i++) {\r\n            // 有负数就+1\r\n            if (nums[i] < 0) {\r\n                negativeCount++;\r\n            }\r\n        }\r\n\r\n        //根据不同的情况，选择要删除的元素\r\n        int tempIndex = 0;\r\n\r\n        if ((negativeCount & 1) == 1) {\r\n            //情况1： 负数个数是奇数,就移除最大的负数\r\n            for (int i = 1; i < nums.length; i++) {\r\n//                int cur = nums[i];\r\n                if (nums[i] < 0 && nums[i] < nums[tempIndex]) {\r\n                    tempIndex = i;\r\n                }\r\n            }\r\n            return tempIndex;\r\n\r\n        } else {  //情况2： 负数个数是偶数\r\n            for (int i = 1; i < nums.length; i++) {\r\n                if (nums[i]>=0 && nums[i] < nums[tempIndex]) {\r\n                    tempIndex = i;\r\n                }\r\n            }\r\n            return tempIndex;\r\n        }\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/hehe/ArrayAndList/ArrayQs.java	(revision 79d57d9e763be873f119b087b927e21eecb34bd3)
+++ src/com/hehe/ArrayAndList/ArrayQs.java	(date 1600241244338)
@@ -74,12 +74,12 @@
      * @param nums
      */
     public void moveZeroes(int[] nums) {
-        int j = 0;
+        int k = 0;
         for (int i = 0; i < nums.length; i++) {
             if (nums[i] != 0)
-                nums[j++] = nums[i];
+                nums[k++] = nums[i];
         }
-        for (int i = j; i < nums.length; i++) {
+        for (int i = k; i < nums.length; i++) {
             nums[i] = 0;
         }
     }
